// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package kv

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

type MessageKind byte

const (
	MessageKindNONE        MessageKind = 0
	MessageKindPingRequest MessageKind = 1
	MessageKindPutRequest  MessageKind = 2
	MessageKindGetRequest  MessageKind = 3
	MessageKindListRequest MessageKind = 4
	MessageKindPingReply   MessageKind = 5
	MessageKindPutReply    MessageKind = 6
	MessageKindGetReply    MessageKind = 7
	MessageKindListReply   MessageKind = 8
	MessageKindErrorReply  MessageKind = 9
)

var EnumNamesMessageKind = map[MessageKind]string{
	MessageKindNONE:        "NONE",
	MessageKindPingRequest: "PingRequest",
	MessageKindPutRequest:  "PutRequest",
	MessageKindGetRequest:  "GetRequest",
	MessageKindListRequest: "ListRequest",
	MessageKindPingReply:   "PingReply",
	MessageKindPutReply:    "PutReply",
	MessageKindGetReply:    "GetReply",
	MessageKindListReply:   "ListReply",
	MessageKindErrorReply:  "ErrorReply",
}

var EnumValuesMessageKind = map[string]MessageKind{
	"NONE":        MessageKindNONE,
	"PingRequest": MessageKindPingRequest,
	"PutRequest":  MessageKindPutRequest,
	"GetRequest":  MessageKindGetRequest,
	"ListRequest": MessageKindListRequest,
	"PingReply":   MessageKindPingReply,
	"PutReply":    MessageKindPutReply,
	"GetReply":    MessageKindGetReply,
	"ListReply":   MessageKindListReply,
	"ErrorReply":  MessageKindErrorReply,
}

func (v MessageKind) String() string {
	if s, ok := EnumNamesMessageKind[v]; ok {
		return s
	}
	return "MessageKind(" + strconv.FormatInt(int64(v), 10) + ")"
}

type PingRequest struct {
	_tab flatbuffers.Table
}

func GetRootAsPingRequest(buf []byte, offset flatbuffers.UOffsetT) *PingRequest {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PingRequest{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PingRequest) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PingRequest) Table() flatbuffers.Table {
	return rcv._tab
}

func PingRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func PingRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type PingReply struct {
	_tab flatbuffers.Table
}

func GetRootAsPingReply(buf []byte, offset flatbuffers.UOffsetT) *PingReply {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PingReply{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PingReply) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PingReply) Table() flatbuffers.Table {
	return rcv._tab
}

func PingReplyStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func PingReplyEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ErrorReply struct {
	_tab flatbuffers.Table
}

func GetRootAsErrorReply(buf []byte, offset flatbuffers.UOffsetT) *ErrorReply {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ErrorReply{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ErrorReply) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ErrorReply) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ErrorReply) Code() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ErrorReply) MutateCode(n uint16) bool {
	return rcv._tab.MutateUint16Slot(4, n)
}

func (rcv *ErrorReply) Message() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ErrorReplyStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func ErrorReplyAddCode(builder *flatbuffers.Builder, code uint16) {
	builder.PrependUint16Slot(0, code, 0)
}
func ErrorReplyAddMessage(builder *flatbuffers.Builder, message flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(message), 0)
}
func ErrorReplyEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type PutRequest struct {
	_tab flatbuffers.Table
}

func GetRootAsPutRequest(buf []byte, offset flatbuffers.UOffsetT) *PutRequest {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PutRequest{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PutRequest) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PutRequest) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PutRequest) Base() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *PutRequest) Key() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *PutRequest) Version() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PutRequest) MutateVersion(n uint64) bool {
	return rcv._tab.MutateUint64Slot(8, n)
}

func (rcv *PutRequest) Value() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func PutRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func PutRequestAddBase(builder *flatbuffers.Builder, base flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(base), 0)
}
func PutRequestAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(key), 0)
}
func PutRequestAddVersion(builder *flatbuffers.Builder, version uint64) {
	builder.PrependUint64Slot(2, version, 0)
}
func PutRequestAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(value), 0)
}
func PutRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type PutReply struct {
	_tab flatbuffers.Table
}

func GetRootAsPutReply(buf []byte, offset flatbuffers.UOffsetT) *PutReply {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PutReply{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PutReply) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PutReply) Table() flatbuffers.Table {
	return rcv._tab
}

func PutReplyStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func PutReplyEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type GetRequest struct {
	_tab flatbuffers.Table
}

func GetRootAsGetRequest(buf []byte, offset flatbuffers.UOffsetT) *GetRequest {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &GetRequest{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *GetRequest) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *GetRequest) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *GetRequest) Base() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GetRequest) Key() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GetRequest) Version() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GetRequest) MutateVersion(n uint64) bool {
	return rcv._tab.MutateUint64Slot(8, n)
}

func GetRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func GetRequestAddBase(builder *flatbuffers.Builder, base flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(base), 0)
}
func GetRequestAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(key), 0)
}
func GetRequestAddVersion(builder *flatbuffers.Builder, version uint64) {
	builder.PrependUint64Slot(2, version, 0)
}
func GetRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type GetReply struct {
	_tab flatbuffers.Table
}

func GetRootAsGetReply(buf []byte, offset flatbuffers.UOffsetT) *GetReply {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &GetReply{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *GetReply) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *GetReply) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *GetReply) Value() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GetReply) Version() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GetReply) MutateVersion(n uint64) bool {
	return rcv._tab.MutateUint64Slot(6, n)
}

func GetReplyStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func GetReplyAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(value), 0)
}
func GetReplyAddVersion(builder *flatbuffers.Builder, version uint64) {
	builder.PrependUint64Slot(1, version, 0)
}
func GetReplyEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ListRequest struct {
	_tab flatbuffers.Table
}

func GetRootAsListRequest(buf []byte, offset flatbuffers.UOffsetT) *ListRequest {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ListRequest{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ListRequest) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ListRequest) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ListRequest) Base() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ListRequest) Marker() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ListRequest) MarkerVersion() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ListRequest) MutateMarkerVersion(n uint64) bool {
	return rcv._tab.MutateUint64Slot(8, n)
}

func (rcv *ListRequest) Max() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ListRequest) MutateMax(n uint16) bool {
	return rcv._tab.MutateUint16Slot(10, n)
}

func ListRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ListRequestAddBase(builder *flatbuffers.Builder, base flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(base), 0)
}
func ListRequestAddMarker(builder *flatbuffers.Builder, marker flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(marker), 0)
}
func ListRequestAddMarkerVersion(builder *flatbuffers.Builder, markerVersion uint64) {
	builder.PrependUint64Slot(2, markerVersion, 0)
}
func ListRequestAddMax(builder *flatbuffers.Builder, max uint16) {
	builder.PrependUint16Slot(3, max, 0)
}
func ListRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ListEntry struct {
	_tab flatbuffers.Table
}

func GetRootAsListEntry(buf []byte, offset flatbuffers.UOffsetT) *ListEntry {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ListEntry{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ListEntry) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ListEntry) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ListEntry) Key() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ListEntry) Version() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ListEntry) MutateVersion(n uint64) bool {
	return rcv._tab.MutateUint64Slot(6, n)
}

func ListEntryStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func ListEntryAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(key), 0)
}
func ListEntryAddVersion(builder *flatbuffers.Builder, version uint64) {
	builder.PrependUint64Slot(1, version, 0)
}
func ListEntryEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ListReply struct {
	_tab flatbuffers.Table
}

func GetRootAsListReply(buf []byte, offset flatbuffers.UOffsetT) *ListReply {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ListReply{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ListReply) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ListReply) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ListReply) Items(obj *ListEntry, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ListReply) ItemsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func ListReplyStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func ListReplyAddItems(builder *flatbuffers.Builder, items flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(items), 0)
}
func ListReplyStartItemsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ListReplyEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Message struct {
	_tab flatbuffers.Table
}

func GetRootAsMessage(buf []byte, offset flatbuffers.UOffsetT) *Message {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Message{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Message) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Message) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Message) ReqId() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Message) MutateReqId(n uint64) bool {
	return rcv._tab.MutateUint64Slot(4, n)
}

func (rcv *Message) ActualType() MessageKind {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return MessageKind(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Message) MutateActualType(n MessageKind) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *Message) Actual(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func MessageStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func MessageAddReqId(builder *flatbuffers.Builder, reqId uint64) {
	builder.PrependUint64Slot(0, reqId, 0)
}
func MessageAddActualType(builder *flatbuffers.Builder, actualType MessageKind) {
	builder.PrependByteSlot(1, byte(actualType), 0)
}
func MessageAddActual(builder *flatbuffers.Builder, actual flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(actual), 0)
}
func MessageEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
