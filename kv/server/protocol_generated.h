// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOL_KV_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_PROTOCOL_KV_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace kv {
namespace protocol {

struct PingRequest;

struct PingReply;

struct ErrorReply;

struct PutRequest;

struct PutReply;

struct GetRequest;

struct GetReply;

struct ListRequest;

struct ListEntry;

struct ListReply;

struct Message;

enum MessageKind {
  MessageKind_NONE = 0,
  MessageKind_PingRequest = 1,
  MessageKind_PutRequest = 2,
  MessageKind_GetRequest = 3,
  MessageKind_ListRequest = 4,
  MessageKind_PingReply = 5,
  MessageKind_PutReply = 6,
  MessageKind_GetReply = 7,
  MessageKind_ListReply = 8,
  MessageKind_ErrorReply = 9,
  MessageKind_MIN = MessageKind_NONE,
  MessageKind_MAX = MessageKind_ErrorReply
};

inline const MessageKind (&EnumValuesMessageKind())[10] {
  static const MessageKind values[] = {
    MessageKind_NONE,
    MessageKind_PingRequest,
    MessageKind_PutRequest,
    MessageKind_GetRequest,
    MessageKind_ListRequest,
    MessageKind_PingReply,
    MessageKind_PutReply,
    MessageKind_GetReply,
    MessageKind_ListReply,
    MessageKind_ErrorReply
  };
  return values;
}

inline const char * const *EnumNamesMessageKind() {
  static const char * const names[11] = {
    "NONE",
    "PingRequest",
    "PutRequest",
    "GetRequest",
    "ListRequest",
    "PingReply",
    "PutReply",
    "GetReply",
    "ListReply",
    "ErrorReply",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageKind(MessageKind e) {
  if (e < MessageKind_NONE || e > MessageKind_ErrorReply) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageKind()[index];
}

template<typename T> struct MessageKindTraits {
  static const MessageKind enum_value = MessageKind_NONE;
};

template<> struct MessageKindTraits<kv::protocol::PingRequest> {
  static const MessageKind enum_value = MessageKind_PingRequest;
};

template<> struct MessageKindTraits<kv::protocol::PutRequest> {
  static const MessageKind enum_value = MessageKind_PutRequest;
};

template<> struct MessageKindTraits<kv::protocol::GetRequest> {
  static const MessageKind enum_value = MessageKind_GetRequest;
};

template<> struct MessageKindTraits<kv::protocol::ListRequest> {
  static const MessageKind enum_value = MessageKind_ListRequest;
};

template<> struct MessageKindTraits<kv::protocol::PingReply> {
  static const MessageKind enum_value = MessageKind_PingReply;
};

template<> struct MessageKindTraits<kv::protocol::PutReply> {
  static const MessageKind enum_value = MessageKind_PutReply;
};

template<> struct MessageKindTraits<kv::protocol::GetReply> {
  static const MessageKind enum_value = MessageKind_GetReply;
};

template<> struct MessageKindTraits<kv::protocol::ListReply> {
  static const MessageKind enum_value = MessageKind_ListReply;
};

template<> struct MessageKindTraits<kv::protocol::ErrorReply> {
  static const MessageKind enum_value = MessageKind_ErrorReply;
};

bool VerifyMessageKind(flatbuffers::Verifier &verifier, const void *obj, MessageKind type);
bool VerifyMessageKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct PingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PingRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PingRequestBuilder &operator=(const PingRequestBuilder &);
  flatbuffers::Offset<PingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PingRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PingRequest> CreatePingRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PingRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PingReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PingReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PingReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PingReplyBuilder &operator=(const PingReplyBuilder &);
  flatbuffers::Offset<PingReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PingReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<PingReply> CreatePingReply(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PingReplyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ErrorReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6
  };
  uint16_t code() const {
    return GetField<uint16_t>(VT_CODE, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ErrorReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(uint16_t code) {
    fbb_.AddElement<uint16_t>(ErrorReply::VT_CODE, code, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(ErrorReply::VT_MESSAGE, message);
  }
  explicit ErrorReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorReplyBuilder &operator=(const ErrorReplyBuilder &);
  flatbuffers::Offset<ErrorReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ErrorReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<ErrorReply> CreateErrorReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t code = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  ErrorReplyBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<ErrorReply> CreateErrorReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t code = 0,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return kv::protocol::CreateErrorReply(
      _fbb,
      code,
      message__);
}

struct PutRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_KEY = 6,
    VT_VERSION = 8,
    VT_VALUE = 10
  };
  const flatbuffers::String *base() const {
    return GetPointer<const flatbuffers::String *>(VT_BASE);
  }
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  uint64_t version() const {
    return GetField<uint64_t>(VT_VERSION, 0);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyString(base()) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<uint64_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct PutRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<flatbuffers::String> base) {
    fbb_.AddOffset(PutRequest::VT_BASE, base);
  }
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(PutRequest::VT_KEY, key);
  }
  void add_version(uint64_t version) {
    fbb_.AddElement<uint64_t>(PutRequest::VT_VERSION, version, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(PutRequest::VT_VALUE, value);
  }
  explicit PutRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PutRequestBuilder &operator=(const PutRequestBuilder &);
  flatbuffers::Offset<PutRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PutRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PutRequest> CreatePutRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> base = 0,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    uint64_t version = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  PutRequestBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<PutRequest> CreatePutRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *base = nullptr,
    const char *key = nullptr,
    uint64_t version = 0,
    const char *value = nullptr) {
  auto base__ = base ? _fbb.CreateString(base) : 0;
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return kv::protocol::CreatePutRequest(
      _fbb,
      base__,
      key__,
      version,
      value__);
}

struct PutReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PutReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PutReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PutReplyBuilder &operator=(const PutReplyBuilder &);
  flatbuffers::Offset<PutReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PutReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<PutReply> CreatePutReply(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PutReplyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GetRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_KEY = 6,
    VT_VERSION = 8
  };
  const flatbuffers::String *base() const {
    return GetPointer<const flatbuffers::String *>(VT_BASE);
  }
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  uint64_t version() const {
    return GetField<uint64_t>(VT_VERSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyString(base()) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<uint64_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
};

struct GetRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<flatbuffers::String> base) {
    fbb_.AddOffset(GetRequest::VT_BASE, base);
  }
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(GetRequest::VT_KEY, key);
  }
  void add_version(uint64_t version) {
    fbb_.AddElement<uint64_t>(GetRequest::VT_VERSION, version, 0);
  }
  explicit GetRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetRequestBuilder &operator=(const GetRequestBuilder &);
  flatbuffers::Offset<GetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetRequest> CreateGetRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> base = 0,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    uint64_t version = 0) {
  GetRequestBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_key(key);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetRequest> CreateGetRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *base = nullptr,
    const char *key = nullptr,
    uint64_t version = 0) {
  auto base__ = base ? _fbb.CreateString(base) : 0;
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return kv::protocol::CreateGetRequest(
      _fbb,
      base__,
      key__,
      version);
}

struct GetReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_VERSION = 6
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  uint64_t version() const {
    return GetField<uint64_t>(VT_VERSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           VerifyField<uint64_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
};

struct GetReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(GetReply::VT_VALUE, value);
  }
  void add_version(uint64_t version) {
    fbb_.AddElement<uint64_t>(GetReply::VT_VERSION, version, 0);
  }
  explicit GetReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetReplyBuilder &operator=(const GetReplyBuilder &);
  flatbuffers::Offset<GetReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetReply> CreateGetReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0,
    uint64_t version = 0) {
  GetReplyBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetReply> CreateGetReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr,
    uint64_t version = 0) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return kv::protocol::CreateGetReply(
      _fbb,
      value__,
      version);
}

struct ListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_MARKER = 6,
    VT_MARKERVERSION = 8,
    VT_MAX = 10
  };
  const flatbuffers::String *base() const {
    return GetPointer<const flatbuffers::String *>(VT_BASE);
  }
  const flatbuffers::String *marker() const {
    return GetPointer<const flatbuffers::String *>(VT_MARKER);
  }
  uint64_t markerVersion() const {
    return GetField<uint64_t>(VT_MARKERVERSION, 0);
  }
  uint16_t max() const {
    return GetField<uint16_t>(VT_MAX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyString(base()) &&
           VerifyOffset(verifier, VT_MARKER) &&
           verifier.VerifyString(marker()) &&
           VerifyField<uint64_t>(verifier, VT_MARKERVERSION) &&
           VerifyField<uint16_t>(verifier, VT_MAX) &&
           verifier.EndTable();
  }
};

struct ListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<flatbuffers::String> base) {
    fbb_.AddOffset(ListRequest::VT_BASE, base);
  }
  void add_marker(flatbuffers::Offset<flatbuffers::String> marker) {
    fbb_.AddOffset(ListRequest::VT_MARKER, marker);
  }
  void add_markerVersion(uint64_t markerVersion) {
    fbb_.AddElement<uint64_t>(ListRequest::VT_MARKERVERSION, markerVersion, 0);
  }
  void add_max(uint16_t max) {
    fbb_.AddElement<uint16_t>(ListRequest::VT_MAX, max, 0);
  }
  explicit ListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ListRequestBuilder &operator=(const ListRequestBuilder &);
  flatbuffers::Offset<ListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ListRequest> CreateListRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> base = 0,
    flatbuffers::Offset<flatbuffers::String> marker = 0,
    uint64_t markerVersion = 0,
    uint16_t max = 0) {
  ListRequestBuilder builder_(_fbb);
  builder_.add_markerVersion(markerVersion);
  builder_.add_marker(marker);
  builder_.add_base(base);
  builder_.add_max(max);
  return builder_.Finish();
}

inline flatbuffers::Offset<ListRequest> CreateListRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *base = nullptr,
    const char *marker = nullptr,
    uint64_t markerVersion = 0,
    uint16_t max = 0) {
  auto base__ = base ? _fbb.CreateString(base) : 0;
  auto marker__ = marker ? _fbb.CreateString(marker) : 0;
  return kv::protocol::CreateListRequest(
      _fbb,
      base__,
      marker__,
      markerVersion,
      max);
}

struct ListEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VERSION = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  uint64_t version() const {
    return GetField<uint64_t>(VT_VERSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<uint64_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
};

struct ListEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(ListEntry::VT_KEY, key);
  }
  void add_version(uint64_t version) {
    fbb_.AddElement<uint64_t>(ListEntry::VT_VERSION, version, 0);
  }
  explicit ListEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ListEntryBuilder &operator=(const ListEntryBuilder &);
  flatbuffers::Offset<ListEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ListEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<ListEntry> CreateListEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    uint64_t version = 0) {
  ListEntryBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<ListEntry> CreateListEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    uint64_t version = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return kv::protocol::CreateListEntry(
      _fbb,
      key__,
      version);
}

struct ListReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<kv::protocol::ListEntry>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<kv::protocol::ListEntry>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct ListReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<kv::protocol::ListEntry>>> items) {
    fbb_.AddOffset(ListReply::VT_ITEMS, items);
  }
  explicit ListReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ListReplyBuilder &operator=(const ListReplyBuilder &);
  flatbuffers::Offset<ListReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ListReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<ListReply> CreateListReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<kv::protocol::ListEntry>>> items = 0) {
  ListReplyBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<ListReply> CreateListReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<kv::protocol::ListEntry>> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<flatbuffers::Offset<kv::protocol::ListEntry>>(*items) : 0;
  return kv::protocol::CreateListReply(
      _fbb,
      items__);
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQID = 4,
    VT_ACTUAL_TYPE = 6,
    VT_ACTUAL = 8
  };
  uint64_t reqId() const {
    return GetField<uint64_t>(VT_REQID, 0);
  }
  kv::protocol::MessageKind actual_type() const {
    return static_cast<kv::protocol::MessageKind>(GetField<uint8_t>(VT_ACTUAL_TYPE, 0));
  }
  const void *actual() const {
    return GetPointer<const void *>(VT_ACTUAL);
  }
  template<typename T> const T *actual_as() const;
  const kv::protocol::PingRequest *actual_as_PingRequest() const {
    return actual_type() == kv::protocol::MessageKind_PingRequest ? static_cast<const kv::protocol::PingRequest *>(actual()) : nullptr;
  }
  const kv::protocol::PutRequest *actual_as_PutRequest() const {
    return actual_type() == kv::protocol::MessageKind_PutRequest ? static_cast<const kv::protocol::PutRequest *>(actual()) : nullptr;
  }
  const kv::protocol::GetRequest *actual_as_GetRequest() const {
    return actual_type() == kv::protocol::MessageKind_GetRequest ? static_cast<const kv::protocol::GetRequest *>(actual()) : nullptr;
  }
  const kv::protocol::ListRequest *actual_as_ListRequest() const {
    return actual_type() == kv::protocol::MessageKind_ListRequest ? static_cast<const kv::protocol::ListRequest *>(actual()) : nullptr;
  }
  const kv::protocol::PingReply *actual_as_PingReply() const {
    return actual_type() == kv::protocol::MessageKind_PingReply ? static_cast<const kv::protocol::PingReply *>(actual()) : nullptr;
  }
  const kv::protocol::PutReply *actual_as_PutReply() const {
    return actual_type() == kv::protocol::MessageKind_PutReply ? static_cast<const kv::protocol::PutReply *>(actual()) : nullptr;
  }
  const kv::protocol::GetReply *actual_as_GetReply() const {
    return actual_type() == kv::protocol::MessageKind_GetReply ? static_cast<const kv::protocol::GetReply *>(actual()) : nullptr;
  }
  const kv::protocol::ListReply *actual_as_ListReply() const {
    return actual_type() == kv::protocol::MessageKind_ListReply ? static_cast<const kv::protocol::ListReply *>(actual()) : nullptr;
  }
  const kv::protocol::ErrorReply *actual_as_ErrorReply() const {
    return actual_type() == kv::protocol::MessageKind_ErrorReply ? static_cast<const kv::protocol::ErrorReply *>(actual()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REQID) &&
           VerifyField<uint8_t>(verifier, VT_ACTUAL_TYPE) &&
           VerifyOffset(verifier, VT_ACTUAL) &&
           VerifyMessageKind(verifier, actual(), actual_type()) &&
           verifier.EndTable();
  }
};

template<> inline const kv::protocol::PingRequest *Message::actual_as<kv::protocol::PingRequest>() const {
  return actual_as_PingRequest();
}

template<> inline const kv::protocol::PutRequest *Message::actual_as<kv::protocol::PutRequest>() const {
  return actual_as_PutRequest();
}

template<> inline const kv::protocol::GetRequest *Message::actual_as<kv::protocol::GetRequest>() const {
  return actual_as_GetRequest();
}

template<> inline const kv::protocol::ListRequest *Message::actual_as<kv::protocol::ListRequest>() const {
  return actual_as_ListRequest();
}

template<> inline const kv::protocol::PingReply *Message::actual_as<kv::protocol::PingReply>() const {
  return actual_as_PingReply();
}

template<> inline const kv::protocol::PutReply *Message::actual_as<kv::protocol::PutReply>() const {
  return actual_as_PutReply();
}

template<> inline const kv::protocol::GetReply *Message::actual_as<kv::protocol::GetReply>() const {
  return actual_as_GetReply();
}

template<> inline const kv::protocol::ListReply *Message::actual_as<kv::protocol::ListReply>() const {
  return actual_as_ListReply();
}

template<> inline const kv::protocol::ErrorReply *Message::actual_as<kv::protocol::ErrorReply>() const {
  return actual_as_ErrorReply();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reqId(uint64_t reqId) {
    fbb_.AddElement<uint64_t>(Message::VT_REQID, reqId, 0);
  }
  void add_actual_type(kv::protocol::MessageKind actual_type) {
    fbb_.AddElement<uint8_t>(Message::VT_ACTUAL_TYPE, static_cast<uint8_t>(actual_type), 0);
  }
  void add_actual(flatbuffers::Offset<void> actual) {
    fbb_.AddOffset(Message::VT_ACTUAL, actual);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t reqId = 0,
    kv::protocol::MessageKind actual_type = kv::protocol::MessageKind_NONE,
    flatbuffers::Offset<void> actual = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_reqId(reqId);
  builder_.add_actual(actual);
  builder_.add_actual_type(actual_type);
  return builder_.Finish();
}

inline bool VerifyMessageKind(flatbuffers::Verifier &verifier, const void *obj, MessageKind type) {
  switch (type) {
    case MessageKind_NONE: {
      return true;
    }
    case MessageKind_PingRequest: {
      auto ptr = reinterpret_cast<const kv::protocol::PingRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageKind_PutRequest: {
      auto ptr = reinterpret_cast<const kv::protocol::PutRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageKind_GetRequest: {
      auto ptr = reinterpret_cast<const kv::protocol::GetRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageKind_ListRequest: {
      auto ptr = reinterpret_cast<const kv::protocol::ListRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageKind_PingReply: {
      auto ptr = reinterpret_cast<const kv::protocol::PingReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageKind_PutReply: {
      auto ptr = reinterpret_cast<const kv::protocol::PutReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageKind_GetReply: {
      auto ptr = reinterpret_cast<const kv::protocol::GetReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageKind_ListReply: {
      auto ptr = reinterpret_cast<const kv::protocol::ListReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageKind_ErrorReply: {
      auto ptr = reinterpret_cast<const kv::protocol::ErrorReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageKindVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageKind(
        verifier,  values->Get(i), types->GetEnum<MessageKind>(i))) {
      return false;
    }
  }
  return true;
}

inline const kv::protocol::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<kv::protocol::Message>(buf);
}

inline const kv::protocol::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<kv::protocol::Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<kv::protocol::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<kv::protocol::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<kv::protocol::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<kv::protocol::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace protocol
}  // namespace kv

#endif  // FLATBUFFERS_GENERATED_PROTOCOL_KV_PROTOCOL_H_
